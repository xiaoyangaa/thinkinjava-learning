1.关于this

对于同一个类中的方法，如果有两个对象来调用，那么编译器如何是区分开这两个对象的呢？
        Car car = new Car(1,"dazhong");
        Car car2 = new Car(2,"dazhong");

        car.move();

        car2.move();

这里其实是Car.move(car1),Car.move(car2),也就是说编译器的层面上会把这个对象的引用传递进去，而这个引用在方法中，可以通过this来获取到。




代理：

不是继承，也不是组合，是二者之间的中庸选择，他应该是拥有目标类的所有方法，但是并不是通过继承的方式得来，而是通过组合的手段，因为本职上代理并隶属于那个目标类，他只是应该拥有他的方法而已，所以从这个角度来看，代理这个名字非常的贴切。

举个例子，奔驰总公司负责汽车服务，某个旗下的子公司除了汽车服务外，还提供了自行车服务，那这个子公司和总公司之间就应该是继承关系，因为本质上这家子公司也是奔驰公司。
那假如出现了一个车展，这个车展只负责展示汽车，除了奔驰还有宝马各种车，那这个车展应该包含奔驰公司这个对象，并且只包含展示汽车这一项功能，这种就是组合。
但是有一家代理商负责奔驰汽车的代理工作，奔驰公司旗下的所有汽车服务都经手他，同时，他还有一些自己的事情，比如自己提供分期付款并且收取一些金融服务费啥的，那这个时候，他并不是奔驰公司，但是拥有奔驰公司这个对象，同时奔驰公司有的所有服务他也都能提供，这玩意儿就叫代理。

静态代理和动态代理的区别：

最大的区别在于，静态代理必须要实现要代理的接口，而动态代理是不需要的，如果是jdk自带的话，直接把要代理的接口的实现类注入进去，如果是cglib的话，直接把某个类注入进去，就可以生成这个代理的实例了。



关于final：

1.final如果是基本数据类型就是常量，如果是引用则标明引用不可变，但是引用的对象本身可以变
2.static final和final的区别在于，static是属于这个类的，仅此一份，无论新生成多少个对象，也就是只有一份；
3.final如果放在入参前面，同样的表示这个参数的引用是不可变的，这个特性在普通方法里不怎么用到，但是在匿名内部类里面传递数据时很有用，个人理解是因为这种匿名内部类通常对于外部来说是不可控的，所以传递进去的参数要求不可变是一种保护。
4.final放在方法前面，现在唯一的作用就是明令禁止这个方法被覆盖了。


关于初始化：
很符合逻辑的一个思路是，只有基类的初始化是ok 的，那么你自己的初始化才是ok的，如果基类的初始化都没有完成，那你甚至都没有必要进行下去了。所以在构造器构造的时候，一定是先基类后自己，层层递归先往上调用的。
同样，销毁的时候，应该是反过来的，先销毁自己的，因为有些可能属于基类的成员变量还在发挥作用，所以先自己，再基类


关于向上转型和向下转型：
很明显的，在程序设计中，向上转型一定是没有问题的，假设蔬菜继承了食物，那么很明显，蔬菜拥有食物的所有公开方法，但是你没法保证食物一定是蔬菜，所以需要一种特殊的手段来确保向下的转型是安全的。

这种向下的CAST如果不做，在编译期就无法通过，而如果失败了，会在运行期抛出一个ClassCastException


关于抽象类和接口：

其实日常中这两种都会用到，接口是更进一步的抽象，何时使用抽象类何时使用接口呢？其实这俩最大的区别在于，抽象类它是个类，是包含属性和行为的，更像是个名词，只不过这个名词的一些行为是抽象的，交由子类去实现的，而接口只是行为，更像是个动词，是对于行为本身的抽象，至于属性是完全不存在的。
所以日常使用中经常发现这两者同时使用的场景：
比如说：定义一个接口Factory，它的方法是create();
然后定义一个abstractFactory，实现这个create（）方法，同时有很多自己的属性和构造器方法以及自己的其他方法；
最后定义各式各样的子类XXXFactory来继承那个abstractFactory。

为什么这么搞呢？因为首先，这个facotry接口是高度抽象的一些同类型动作和行为的集合，而abstractFactory是对这个类的抽象，他包含一些大家都需要的一些属性，并且可能的话，他提供了通用的实现方式；



关于嵌套接口：

最早接触的时候，是在netty的channel接口中，有个unsafe的接口，当时觉得蛮奇怪不能理解的，现在看来这个东西可能最大的作用，在于内部的逻辑分组和封装，这个可能是同一类中的更细分的一类行为吧。



关于内部类：
1.在拥有外部类对象之前是没有办法生成内部类的，这是因为内部类会偷偷的包含一个外部类对象的引用，所以内部类必须由外部类的对象来创建，并且它还拥有外部类对象的成员变量的访问权限；

2.匿名内部类只能访问final类型的变量？

想一想如下这个例子：

public class Test {
    public static void main(String[] args)  {
         test(11);
    }
     
    public void test(final int a) {
        new Thread(){
            public void run() {
                System.out.println(a);
            };
        }.start();
    }
}
我们知道每个方法执行的时候，每个线程是有自己的虚拟机栈，而局部变量是存储在这个虚拟机栈上，是跟着整个方法的执行和退出做栈的入栈和出栈，那么很明显，test是主线程执行，而test里的run方法是另一个线程执行，那么局部变量其实是存储在不同的栈帧上的，这二者之间是难以共享的。
所以事实上java采用了 复制  的手段来解决这个问题：
　如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。
所以，在run方法中访问的变量就已经不再是原有的变量了，所以这就带来了一个问题，如果修改了run方法中的变量会怎么办？这个时候是会造成困惑的。所以Java的设计者干脆就直接把这个东西强制要求为final，那我们就知道这个东西是不可变的，也就避免了这种数据不一致的情况。


3.为什么要使用内部类？
既然这本书叫java编程思想，那我们还是尽量拔高一些来体会，为什么我们需要内部类，内部类又体现了哪些Java的编程哲学呢？
1.封装思想的体现，把一个类的权限降低到最低，正常来说一个类起码来说是包内其他类都可以访问的，而内部类可以做到只有它的外部类才能访问，其他所有人都访问不了，有没有这样的例子呢？
是有的，比如数据库连接池：


2.实现多重继承，这个也是Java编程思想中特别看重的一个地方，因为Java如果要继承多个接口是没有问题的，但是如果要继承多个类呢？这个在语法层面上是不允许的，因此通过内部类就可以实现这一点，外部类继承A，内部类继承B，再搞个get方法就可以实现多重继承了。
感觉这个东西其实有点像组合的意思了，只是这个被注入的实例是当前类的内部类，相对来说层级关系上更加贴近，封装性也更强。




关于异常：

总的基类都是throwable，下面又区分成error和Exception，error通常是应用程序不需要考虑的；
而Exception的话，从javac的角度，可以区分为两类，一类是编译时就需要处理的checkedException，一个是编译时不用处理，而是运行时的异常：runtimeException。
从语法的角度来说，如果是checkedException,那么在方法体上要么加上throws，要么就try catch，而runtimeException可以无需在语法层面做任何处理。

那么真正重点的问题来了，异常这个东西，
1：何时抛
2：抛什么？ 
3：何时抓？
4：怎么抓？


关于何时抛？




想一想Java提供的面向对象的语法其实真的非常简单了，一个组合+继承，一个封装+多态，一个抽象类+接口，想一想其实就这么点东西，结果竟然玩出了这么多花样，只能感慨，设计者真的是牛逼。
